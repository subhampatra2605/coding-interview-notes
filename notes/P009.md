# Maximum Product Subarray

[LeetCode Link](https://leetcode.com/problems/maximum-product-subarray/)

## Problem Statement

Given an integer array `nums`, find the contiguous subarray within an array (containing at least one number) which has the largest product and return the product.

**Example 1**

```
Input: nums = [2,3,-2,4]  
Output: 6  
Explanation: [2,3] has the largest product = 6
```

**Example 2**

```
Input: nums = [-2,0,-1]  
Output: 0  
Explanation: The result cannot be 2 because [-2,-1] is not a contiguous subarray.
```

**Constraints**

* `1 <= nums.length <= 2 * 10^4`
* `-10 <= nums[i] <= 10`
* The product of any prefix or suffix of `nums` is guaranteed to fit in a **32-bit integer**.

---

## Brute Force

* Generate all possible subarrays, compute the product of each, and track the maximum.
* Time Complexity: **O(n²)**, Space Complexity: **O(1)**.

---

## Efficient Insight

* Multiplication behaves differently than addition because **negative × negative = positive**.
* At each index, track both:

  * `maxProduct` ending here
  * `minProduct` ending here (because a small negative could become a large positive later)
* Swap `maxProduct` and `minProduct` if current number is negative (to maintain correct multiplication flow).

---

## Pattern

* **Dynamic Programming** with two running values(Two Pointers):

  ```
  maxSoFar = max(nums[i], nums[i] * maxSoFar, nums[i] * minSoFar)
  minSoFar = min(nums[i], nums[i] * tempMax, nums[i] * minSoFar)
  ```
* Keep a global maximum across all `maxSoFar` values.

---

## Code (Java)

```java
class Solution {
    public int maxProduct(int[] nums) {
        int maxProduct = nums[0];  // Max product ending at current position
        int minProduct = nums[0];  // Min product ending at current position
        int result = nums[0];      // Global max product found so far
        
        for (int i = 1; i < nums.length; i++) {
            int tempMax = maxProduct;
            
            // Update max and min products considering current element
            maxProduct = Math.max(nums[i], Math.max(nums[i] * maxProduct, nums[i] * minProduct));
            minProduct = Math.min(nums[i], Math.min(nums[i] * tempMax, nums[i] * minProduct));
            
            // Update the result if needed
            result = Math.max(result, maxProduct);
        }
        
        return result;
    }
}
```

---

## Key Takeaways

* Must track both **max** and **min** products because of negatives.
* Reset to the current element if multiplying makes things worse.
* Time Complexity: **O(n)**, Space Complexity: **O(1)**.
