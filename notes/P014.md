## Problem Name

**Climbing Stairs** (LeetCode #70)

---

## Problem Statement

You are climbing a staircase. It takes `n` steps to reach the top.
Each time you can either climb **1 step** or **2 steps**.
In how many distinct ways can you climb to the top?

---

### Example 1:

**Input:**

```
n = 2
```

**Output:**

```
2
```

**Explanation:**

* 1 step + 1 step
* 2 steps

---

### Example 2:

**Input:**

```
n = 3
```

**Output:**

```
3
```

**Explanation:**

* 1 step + 1 step + 1 step
* 1 step + 2 steps
* 2 steps + 1 step

---

## Observations

* The number of ways to reach step `n` is the sum of:

  * Ways to reach step `n-1` (and take 1 step)
  * Ways to reach step `n-2` (and take 2 steps)
* This forms a **Fibonacci sequence**:

  ```
  ways(n) = ways(n-1) + ways(n-2)
  ```

---

## Brute Force

* Recursively compute `ways(n)`.
* Time Complexity: **O(2ⁿ)** (too slow for large n).

---

## Efficient Insight (Dynamic Programming)

* Use two variables to store the last two results and iterate.
* Time Complexity: **O(n)**
* Space Complexity: **O(1)**

---

## Pattern

* **Dynamic Programming** (Fibonacci type)
* **Bottom-up iteration**

---

## Java Code with Explanation

```java
class Solution {
    public int climbStairs(int n) {
        if (n <= 2) return n;      // Base cases: 1 → 1 way, 2 → 2 ways

        int first = 1;             // ways to reach step 1
        int second = 2;            // ways to reach step 2

        for (int i = 3; i <= n; i++) {
            int third = first + second; // ways to reach current step
            first = second;             // shift for next iteration
            second = third;             // shift for next iteration
        }

        return second;                  // second holds ways for step n
    }
}
```

---

### **Line-by-line Explanation**

1. `if (n <= 2) return n;`

   * If `n` is 1 or 2, answer is directly `n`.

2. `int first = 1;`

   * Number of ways to reach step 1 is `1` (only `1 step`).

3. `int second = 2;`

   * Number of ways to reach step 2 is `2` (`1+1` or `2`).

4. `for (int i = 3; i <= n; i++)`

   * Start from step 3, calculate ways for each step until `n`.

5. `int third = first + second;`

   * The number of ways to reach step `i` is the sum of ways to reach `i-1` and `i-2`.

6. `first = second;`

   * Move `first` forward (it now represents `i-1`).

7. `second = third;`

   * Move `second` forward (it now represents `i`).

8. `return second;`

   * At the end, `second` holds the answer for step `n`.
