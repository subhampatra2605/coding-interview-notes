## Problem Name

**Container With Most Water** (LeetCode #11)

---

## Problem Statement

You are given an integer array `height` of length `n`. There are `n` vertical lines drawn such that the two endpoints of the `i-th` line are `(i, 0)` and `(i, height[i])`.

Find **two lines** that together with the x-axis form a container, such that the container contains the most water.

Return the **maximum amount of water** a container can store.

**Note:** You may not slant the container.

---

### Example 1:

**Input:**

```
height = [1,8,6,2,5,4,8,3,7]
```

**Output:**

```
49
```

**Explanation:**

* The max area is between line at index 1 (height = 8) and index 8 (height = 7).
* Width = 8 - 1 = 7, Height = min(8, 7) = 7
* Area = 7 × 7 = 49

---

### Example 2:

**Input:**

```
height = [1,1]
```

**Output:**

```
1
```

---

## Brute Force

* Check all pairs `(i, j)` and calculate the area:
  `area = (j - i) * min(height[i], height[j])`
* Keep track of the maximum area found.

**Time Complexity:** O(n²)
**Space Complexity:** O(1)

---

## Efficient Insight

* Start with two pointers at the beginning (`left`) and end (`right`).
* Calculate area between them.
* Move the pointer pointing to the **shorter line** inward, since the height is the limiting factor.
* Continue until `left` meets `right`.

**Time Complexity:** O(n)
**Space Complexity:** O(1)

---

## Pattern

* **Two Pointers**
* **Greedy shrinking window**

---

## Java Code with Explanation

```java
class Solution {
    public int maxArea(int[] height) {
        int left = 0;                      // Start pointer at the first line
        int right = height.length - 1;     // End pointer at the last line
        int maxArea = 0;                   // Store maximum water area found

        while (left < right) {             // Continue until pointers meet
            int width = right - left;      // Distance between two lines
            int minHeight = Math.min(height[left], height[right]); // Limiting height
            int area = width * minHeight;  // Calculate current container area
            maxArea = Math.max(maxArea, area); // Update max if current is bigger

            // Move the pointer pointing to the shorter line
            if (height[left] < height[right]) {
                left++;                    // Move left inward
            } else {
                right--;                   // Move right inward
            }
        }
        return maxArea;                    // Return the largest area found
    }
}
```

---

## Key Takeaways

* Always move the pointer at the shorter height to try finding a taller line (increasing area).
* Two pointers drastically reduce the complexity from O(n²) to O(n).
* This is a classic example of **shrinking two-pointer window**.
