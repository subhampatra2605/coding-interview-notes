# Find Minimum in Rotated Sorted Array

[LeetCode Link](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)

## Problem Statement

Suppose an array of length `n` sorted in ascending order is rotated between `1` and `n` times. For example:

* `[0,1,2,4,5,6,7]` might become `[4,5,6,7,0,1,2]`

Given the rotated sorted array `nums` with **unique** elements, return the **minimum** element.
You must write an algorithm that runs in `O(log n)` time.

**Example 1**

```
Input: nums = [3,4,5,1,2]
Output: 1
```

**Example 2**

```
Input: nums = [4,5,6,7,0,1,2]
Output: 0
```

**Example 3**

```
Input: nums = [11,13,15,17]
Output: 11
```

**Constraints**

* `n == nums.length`
* `1 <= n <= 5000`
* `-5000 <= nums[i] <= 5000`
* All integers in `nums` are unique.
* `nums` is sorted and rotated.

---

## Brute Force

* Simply scan the array linearly and track the smallest value.
* Time Complexity: **O(n)**
* Space Complexity: **O(1)**

---

## Efficient Insight

* The array is **rotated sorted**, meaning it consists of two sorted halves.
* Use **binary search**:

  * Compare `nums[mid]` with `nums[high]`.
  * If `nums[mid] > nums[high]`, the minimum is to the right of `mid`.
  * Otherwise, the minimum is at `mid` or to the left.
* This guarantees **O(log n)** time.

---

## Pattern

* **Binary Search on Rotated Array**
* Similar to problems like:

  * Search in Rotated Sorted Array (33)
  * Find Minimum in Rotated Sorted Array II (154)

---

## Code (Java)

```java
class Solution {
    public int findMin(int[] nums) {
        int left = 0;
        int right = nums.length - 1;

        while (left < right) {
            int mid = left + (right - left) / 2;

            // If middle element is greater than rightmost, min is in right half
            if (nums[mid] > nums[right]) {
                left = mid + 1;
            } else {
                // Min is in left half (including mid)
                right = mid;
            }
        }

        // When left == right, we've found the smallest element
        return nums[left];
    }
}
```

---

## Key Takeaways

* Exploits sorted+rotated structure with binary search.
* Pivot point is where rotation happens; smallest element is pivot.
* **Time Complexity:** O(log n)
* **Space Complexity:** O(1)
