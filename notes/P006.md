# Contains Duplicate

[LeetCode Link](https://leetcode.com/problems/contains-duplicate/)

## Problem Statement

Given an integer array `nums`, return `true` if any value appears at least twice in the array, and return `false` if every element is distinct.

---

## Brute Force Approach

* Compare every pair of elements `(i, j)` where `i < j`.
* If any two values are the same, return `true`.
* If the loop finishes without finding duplicates, return `false`.

**Time Complexity**: O(n²) – checks all pairs.
**Space Complexity**: O(1) – no extra data structures.

---

## Efficient Insight

* Use a **HashSet** to store numbers as we iterate.
* Before adding a number to the set, check if it’s already present.
* If yes → duplicate found, return `true`.
* If loop ends without finding duplicates, return `false`.

**Time Complexity**: O(n) – each element is processed once.
**Space Complexity**: O(n) – set stores up to all elements.

---

## Pattern

* **Pattern**: Hashing for Uniqueness Check.
* **Similar Problems**:

  * Contains Duplicate II (LeetCode 219)
  * First Unique Character in a String (LeetCode 387)

---

## Java Code – Brute Force

```java
public boolean containsDuplicateBruteForce(int[] nums) {
    // Compare each element with all the elements after it
    for (int i = 0; i < nums.length; i++) {
        for (int j = i + 1; j < nums.length; j++) {
            // If any two are equal, duplicate found
            if (nums[i] == nums[j]) {
                return true;
            }
        }
    }
    // No duplicates found
    return false;
}
```

---

## Java Code – Optimal (HashSet) with Line-by-Line Comments

```java
import java.util.HashSet;

public boolean containsDuplicateOptimal(int[] nums) {
    // Create a HashSet to store unique elements we've seen so far
    HashSet<Integer> seen = new HashSet<>();

    // Loop through each number in the array
    for (int num : nums) {
        // If the number is already in the set, we found a duplicate
        if (seen.contains(num)) {
            return true;
        }
        // Otherwise, add it to the set for future checks
        seen.add(num);
    }

    // If we finish the loop without returning, all elements are unique
    return false;
}
```

---

## Key Takeaways

* **Brute force** → checks all pairs, inefficient for large arrays.
* **Optimal** → `HashSet` gives O(1) lookup and insertion on average.
* This is a standard **duplicate check pattern** useful in many problems.
