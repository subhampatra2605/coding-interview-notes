# Product of Array Except Self

[LeetCode Link](https://leetcode.com/problems/product-of-array-except-self/)

## Problem Statement

Given an integer array `nums`, return an array `answer` such that `answer[i]` is equal to the product of all the elements of `nums` **except** `nums[i]`.

You must solve it **without** using division and in **O(n)** time.

**Example 1**

```
Input: nums = [1,2,3,4]  
Output: [24,12,8,6]  
Explanation:  
answer[0] = 2 * 3 * 4 = 24  
answer[1] = 1 * 3 * 4 = 12  
answer[2] = 1 * 2 * 4 = 8  
answer[3] = 1 * 2 * 3 = 6
```

**Example 2**

```
Input: nums = [-1,1,0,-3,3]  
Output: [0,0,9,0,0]  
Explanation:  
answer[0] = 1 * 0 * -3 * 3 = 0  
answer[2] = (-1) * 1 * (-3) * 3 = 9
```

**Constraints**

* `2 <= nums.length <= 10^5`
* `-30 <= nums[i] <= 30`
* The product of any prefix or suffix will fit in a **32-bit integer**.

---

## Brute Force Approach

* For each index `i`, multiply all elements except `nums[i]`.
* Store the result in `answer[i]`.

**Time Complexity**: O(n²) – nested loops.
**Space Complexity**: O(1) extra (excluding output array).

---

## Efficient Insight

* Compute **prefix product** for each index (product of all elements to the left).
* Compute **suffix product** (product of all elements to the right) in a single backward pass.
* Multiply prefix and suffix for the result.

**Time Complexity**: O(n).
**Space Complexity**: O(1) extra (excluding output array).

---

## Pattern

* **Pattern**: Prefix & Suffix Products.
* **Similar Problems**:

  * Trapping Rain Water (LeetCode 42)
  * Sum of Array Except Self (concept variation)

---

## Java Code – Brute Force

```java
public int[] productExceptSelfBruteForce(int[] nums) {
    int n = nums.length;
    int[] answer = new int[n];
    
    for (int i = 0; i < n; i++) {
        int product = 1;
        for (int j = 0; j < n; j++) {
            if (i != j) {
                product *= nums[j];
            }
        }
        answer[i] = product;
    }
    return answer;
}
```

---

## Java Code – Optimal (Prefix & Suffix) with Line-by-Line Comments

```java
public int[] productExceptSelfOptimal(int[] nums) {
    int n = nums.length;
    int[] answer = new int[n];
    
    // Step 1: Prefix products
    // answer[i] stores product of all elements to the left of i
    answer[0] = 1;
    for (int i = 1; i < n; i++) {
        answer[i] = answer[i - 1] * nums[i - 1];
    }
    
    // Step 2: Multiply with suffix products
    int suffixProduct = 1; // Product of all elements to the right
    for (int i = n - 1; i >= 0; i--) {
        answer[i] *= suffixProduct;
        suffixProduct *= nums[i];
    }
    
    return answer;
}
```

---

## Key Takeaways

* Avoids division → works even with zeroes in the array.
* Prefix & suffix approach runs in O(n) with constant extra space.
* Brute force is too slow for large arrays.
