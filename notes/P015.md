## Problem Name

**Coin Change** (LeetCode #322)

---

## Problem Statement

You are given an integer array `coins` representing different denominations of coins and an integer `amount` representing a total amount of money.

Return the **fewest number of coins** you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return **-1**.

You may assume that you have an infinite number of each kind of coin.

---

### Example 1:

**Input:**

```
coins = [1, 2, 5], amount = 11
```

**Output:**

```
3
```

**Explanation:**
11 = 5 + 5 + 1 → 3 coins

---

### Example 2:

**Input:**

```
coins = [2], amount = 3
```

**Output:**

```
-1
```

---

### Example 3:

**Input:**

```
coins = [1], amount = 0
```

**Output:**

```
0
```

---

## Brute Force Approach

**Idea:**
Try **all possible combinations** of coins recursively and pick the one with the least number of coins.

**Steps:**

1. For each coin, recursively try to solve for `amount - coin`.
2. Keep track of the minimum coins used.

**Time Complexity:** O(S^n) — exponential (very slow for large amounts).
**Space Complexity:** O(S) for recursion stack.

---

## Efficient Insight (Dynamic Programming - Bottom-Up)

We use **DP** where:

* `dp[i]` = fewest coins needed to make amount `i`.
* Initialize `dp` with a large value (`amount+1`) to represent "impossible".
* Base case: `dp[0] = 0` (0 coins needed to make amount 0).
* For each amount `i` from 1 to `amount`:

  * Check each coin: if `coin <= i`, update `dp[i] = min(dp[i], 1 + dp[i - coin])`.

**Time Complexity:** O(amount × n)
**Space Complexity:** O(amount)

---

## Pattern

* **Dynamic Programming**
* **Unbounded Knapsack**

---

## Java Code with Line-by-Line Explanation

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int max = amount + 1;        // Represents an "infinite" value (unreachable)
        int[] dp = new int[amount + 1]; // dp[i] = min coins to make amount i
        Arrays.fill(dp, max);        // Initially set all as unreachable
        dp[0] = 0;                   // Base case: 0 coins needed for amount 0

        // Outer loop: go through all amounts from 1 to target amount
        for (int i = 1; i <= amount; i++) {
            // Inner loop: try each coin
            for (int coin : coins) {
                if (coin <= i) { // Only consider if coin value <= current amount
                    dp[i] = Math.min(dp[i], dp[i - coin] + 1);
                    // dp[i - coin] + 1 means: use 1 coin + best for (i - coin)
                }
            }
        }

        if(dp[amount] < dp[amount + 1]){
          return dp[amount];
        }

        return -1;
    }
}
```

---

### Explanation of Key Lines

1. **`int max = amount + 1;`**

   * We choose a number larger than the max possible coin count to represent **infinity**.

2. **`Arrays.fill(dp, max);`**

   * Initialize all amounts as unreachable.

3. **`dp[0] = 0;`**

   * Base case: 0 coins are needed to make amount 0.

4. **Outer loop `for (int i = 1; i <= amount; i++)`**

   * Build the solution for each amount from 1 to `amount`.

5. **Inner loop `for (int coin : coins)`**

   * Try using each coin to see if it improves the min coins count for `i`.

6. **`dp[i] = Math.min(dp[i], dp[i - coin] + 1);`**

   * Compare the current known min coins for `i` vs. using this coin plus the best known for `i - coin`.

---

## Key Takeaways

* This is a **classic dynamic programming** problem (unbounded knapsack).
* Brute force recursion is too slow; bottom-up DP gives O(amount × coins) time.
* The trick is initializing `dp` with `amount + 1` (acts as infinity) and building solutions from the ground up.

Do you want me to prepare that dry run?
