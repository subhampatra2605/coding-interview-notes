Best Time to Buy and Sell Stock
LeetCode Link

Problem Statement
You are given an array prices where prices[i] is the price of a given stock on day i.
You want to maximize your profit by choosing a single day to buy one stock and a different day in the future to sell that stock.
Return the maximum profit you can achieve. If no profit is possible, return 0.

Brute Force Approach
Try all possible pairs (buyDay, sellDay) with buyDay < sellDay.

For each pair, calculate profit = prices[sellDay] - prices[buyDay].

Track the maximum profit found.

Time Complexity: O(n²) – two nested loops.
Space Complexity: O(1).

Efficient Insight
Use one pass with two variables:

minPrice → smallest price so far (buy day).

maxProfit → maximum profit seen so far.

For each day’s price:

Update minPrice if current price is lower.

Calculate profit = current price - minPrice, update maxProfit if higher.

Time Complexity: O(n) – single pass.
Space Complexity: O(1) – constant extra space.

Pattern
Pattern: Single Pass Tracking / Kadane’s Variant.

Similar Problems:

Best Time to Buy and Sell Stock II (LeetCode 122)

Maximum Subarray (LeetCode 53)

Java Code – Brute Force
java
Copy
Edit
public int maxProfitBruteForce(int[] prices) {
    int maxProfit = 0;
    for (int i = 0; i < prices.length; i++) {
        for (int j = i + 1; j < prices.length; j++) {
            int profit = prices[j] - prices[i];
            if (profit > maxProfit) {
                maxProfit = profit;
            }
        }
    }
    return maxProfit;
}
Java Code – Optimal (Single Pass) with Line-by-Line Comments
java
Copy
Edit
public int maxProfitOptimal(int[] prices) {
    // Initialize minPrice to a very large value so any price will be smaller initially
    int minPrice = Integer.MAX_VALUE;
    
    // Initialize maxProfit to 0 (no transaction means zero profit)
    int maxProfit = 0;

    // Loop through each day's stock price
    for (int price : prices) {
        
        // If the current price is lower than any we've seen, update minPrice (buy here)
        if (price < minPrice) {
            minPrice = price;
        }
        // Else, calculate the profit if we sold today (price - minPrice so far)
        else if (price - minPrice > maxProfit) {
            // If this profit is better than what we had, update maxProfit
            maxProfit = price - minPrice;
        }
    }

    // After checking all days, maxProfit holds the best possible profit
    return maxProfit;
}
Key Takeaways
Core trick: Keep track of the lowest price seen so far and calculate potential profit in one pass.

This is essentially finding the max difference between two elements where the larger element comes after the smaller.

If prices keep decreasing, profit remains 0.
